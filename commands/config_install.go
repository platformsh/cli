package commands

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"github.com/symfony-cli/terminal"

	"github.com/platformsh/cli/internal/config"
	"github.com/platformsh/cli/internal/config/alt"
)

func newConfigInstallCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "config:install [flags] [url]",
		Short: "Installs an alternative CLI, downloading new configuration from a URL",
		Args:  cobra.ExactArgs(1),
		RunE:  runConfigInstall,
	}
	cmd.Flags().String("bin-dir", "", "Install the executable in the given directory")
	cmd.Flags().String("config-dir", "", "Install the configuration in the given directory")
	cmd.Flags().Bool("absolute", false,
		"Use the absolute path to the current executable, instead of the configured name")
	cmd.Flags().BoolP("force", "f", false, "Force installation even if a duplicate executable exists")
	return cmd
}

func runConfigInstall(cmd *cobra.Command, args []string) error {
	cnf := config.FromContext(cmd.Context())

	// Validate input.
	executableDir, err := getExecutableDir(cmd)
	if err != nil {
		return err
	}
	configDir, err := getConfigDir(cmd)
	if err != nil {
		return err
	}
	target, err := getExecutableTarget(cmd, cnf)
	if err != nil {
		return err
	}

	cmd.PrintErrln("Downloading and validating new CLI configuration...")
	cmd.PrintErrln()

	urlStr := args[0]
	if !strings.Contains(urlStr, "://") {
		urlStr = "https://" + urlStr
	}
	newCnfNode, newCnfStruct, err := alt.FetchConfig(cmd.Context(), urlStr)
	if err != nil {
		return err
	}
	newExecutable := newCnfStruct.Application.Executable
	if newExecutable == cnf.Application.Executable {
		return fmt.Errorf("cannot install config for same executable name as this program: %s", newExecutable)
	}

	configFilePath := filepath.Join(configDir, newExecutable) + ".yaml"
	executableFilePath := filepath.Join(executableDir, newExecutable) + alt.GetExecutableFileExtension()

	pathVariableName := "PATH"
	if runtime.GOOS == "windows" {
		pathVariableName = "Path"
	}

	// Check for duplicates.
	{
		force, err := cmd.Flags().GetBool("force")
		if err != nil {
			return err
		}
		if !force {
			if path, err := exec.LookPath(newExecutable); err == nil && path != executableFilePath {
				cmd.PrintErrln("An executable with the same name already exists at another location.")
				cmd.PrintErrf(
					"Use %s to ignore this check. "+
						"You would need to verify the %s precedence manually.\n",
					color.RedString("--force"),
					pathVariableName,
				)
				return fmt.Errorf("install failed due to duplicate executable with the name %s at: %s", newExecutable, path)
			}
		}
	}

	formatPath := pathFormatter()

	cmd.PrintErrln("The following files will be created or overwritten:")
	cmd.PrintErrf("  Configuration file: %s\n", color.CyanString(formatPath(configFilePath)))
	cmd.PrintErrf("  Executable: %s\n", color.CyanString(formatPath(executableFilePath)))
	cmd.PrintErrf("The executable runs %s with the new configuration.\n",
		color.CyanString(formatPath(target)))
	cmd.PrintErrln()
	if terminal.Stdin.IsInteractive() {
		if !terminal.AskConfirmation("Are you sure you want to continue?", true) {
			os.Exit(1)
		}
		cmd.PrintErrln()
	}

	// Create the files.
	a := alt.New(
		executableFilePath,
		fmt.Sprintf("Automatically generated by the %s", cnf.Application.Name),
		target,
		configFilePath,
		newCnfNode,
	)
	if err := a.GenerateAndSave(); err != nil {
		return err
	}

	cmd.PrintErrln("The files have been saved successfully.")
	cmd.PrintErrln()

	if alt.InPath(executableDir) {
		cmd.PrintErrln("Run the new CLI with:", color.GreenString(newExecutable))
	} else {
		cmd.PrintErrf(
			"Add the following directory to your %s: %s\n",
			pathVariableName,
			color.YellowString(formatPath(executableDir)),
		)
		cmd.PrintErrln()
		cmd.PrintErrln("Then you will be able to run the new CLI with:", color.YellowString(newExecutable))
	}

	return nil
}

// Returns a formatter for displaying file and directory names.
func pathFormatter() func(string) string {
	sub := "~"
	if runtime.GOOS == "windows" {
		sub = "%USERPROFILE%"
	}
	hd, err := os.UserHomeDir()
	return func(p string) string {
		if err == nil && strings.HasPrefix(p, hd) {
			return sub + strings.TrimPrefix(p, hd)
		}
		return p
	}
}

func getExecutableTarget(cmd *cobra.Command, cnf *config.Config) (string, error) {
	abs, err := cmd.Flags().GetBool("absolute")
	if err != nil {
		return "", err
	}
	if abs {
		return os.Executable()
	}
	return cnf.Application.Executable, nil
}

func getConfigDir(cmd *cobra.Command) (string, error) {
	configDirOpt, err := cmd.Flags().GetString("config-dir")
	if err != nil {
		return "", err
	}
	if configDirOpt != "" {
		return validateUserProvidedDir(configDirOpt)
	}
	return alt.FindConfigDir()
}

func getExecutableDir(cmd *cobra.Command) (string, error) {
	binDirOpt, err := cmd.Flags().GetString("bin-dir")
	if err != nil {
		return "", err
	}
	if binDirOpt != "" {
		return validateUserProvidedDir(binDirOpt)
	}
	return alt.FindBinDir()
}

func validateUserProvidedDir(path string) (normalized string, err error) {
	normalized, err = filepath.Abs(path)
	if err != nil {
		return
	}

	lstat, err := os.Lstat(normalized)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			err = fmt.Errorf("directory not found: %s", normalized)
		}
		return
	}
	if !lstat.IsDir() {
		err = fmt.Errorf("not a directory: %s", normalized)
	}

	return
}
