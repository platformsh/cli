package alt

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/upsun/cli/internal/config"
)

// FetchConfig makes an HTTP request to fetch some config YAML, validates it, and returns decoded versions.
//
// The config is unmarshalled to a YAML document node, "cnfNode", to avoid
// needing to know the whole schema, and to preserve comments. A comment and some
// metadata are added to the cnfNode. A "cnfStruct" is also returned to allow
// reading some keys.
//
//nolint:gocritic // The "importShadow" rule complains about the url parameter.
func FetchConfig(ctx context.Context, url string) (cnfNode *yaml.Node, cnfStruct *config.Config, err error) {
	if err := validateConfigURL(url); err != nil {
		return nil, nil, err
	}
	httpClient := &http.Client{Timeout: 10 * time.Second}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
	if err != nil {
		return nil, nil, err
	}
	if cnf, ok := config.MaybeFromContext(ctx); ok {
		req.Header.Set("User-Agent", cnf.UserAgent())
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to fetch config: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, nil, fmt.Errorf("received unexpected response code %d from URL %s", resp.StatusCode, url)
	}
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, nil, err
	}

	return processConfig(b, url, time.Now())
}

func validateConfigURL(urlStr string) error {
	u, err := url.Parse(urlStr)
	if err != nil {
		return err
	}
	if u.Scheme != "https" && u.Hostname() != "127.0.0.1" {
		return fmt.Errorf("invalid config URL scheme (https required)")
	}
	if u.Host == "" {
		return fmt.Errorf("invalid config URL (no host)")
	}
	return nil
}

func processConfig(b []byte, downloadURL string, downloadedAt time.Time) (*yaml.Node, *config.Config, error) {
	// Validate the config.
	cnf, err := config.FromYAML(b)
	if err != nil {
		return nil, nil, err
	}

	// Unmarshal the source YAML to a generic YAML document node.
	node := &yaml.Node{}
	if err := yaml.Unmarshal(b, node); err != nil {
		return nil, nil, err
	}

	// Delete the "wrapper" key from the config document node, if defined.
	// This prevents a confusing update check.
	if err := deleteDocumentKey(node, "wrapper"); err != nil {
		return nil, nil, err
	}

	// Add metadata to the config document node.
	metadata := &cnf.Metadata
	if metadata.URL != "" {
		if err := validateConfigURL(metadata.URL); err != nil {
			return nil, nil, err
		}
	} else {
		metadata.URL = downloadURL
	}
	metadata.DownloadedAt = downloadedAt
	if _err := addMetadata(node, metadata); _err != nil {
		return nil, nil, fmt.Errorf("failed to add config metadata: %w", _err)
	}

	// Add a comment to the config document node.
	node.HeadComment = fmt.Sprintf(
		"%s configuration.\n"+
			"Do not edit this file, as it will be replaced with updated versions automatically.\n",
		cnf.Application.Name,
	)

	return node, cnf, nil
}

// addMetadata adds a "metadata" section to a config document node.
func addMetadata(doc *yaml.Node, metadata *config.Metadata) error {
	node, err := structToYAMLNode(metadata)
	if err != nil {
		return err
	}

	// Delete the existing metadata key if it exists.
	if err := deleteDocumentKey(doc, "metadata"); err != nil {
		return err
	}

	// Add the new key and value.
	keyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Value: "metadata",
	}
	mapNode := doc.Content[0]
	mapNode.Content = append(mapNode.Content, keyNode, node)

	return nil
}

// structToYAMLNode converts a struct to a YAML mapping node.
func structToYAMLNode(s any) (*yaml.Node, error) {
	b, err := yaml.Marshal(s)
	if err != nil {
		return nil, err
	}
	var doc = &yaml.Node{}
	if err := yaml.Unmarshal(b, doc); err != nil {
		return nil, err
	}
	// Unmarshal returns a document node containing 1 mapping node.
	return doc.Content[0], nil
}

func deleteDocumentKey(doc *yaml.Node, toDelete string) error {
	if doc.Kind != yaml.DocumentNode {
		return fmt.Errorf("unable to delete key: the node is not a document")
	}
	mapNode := doc.Content[0]
	// The map node contains keys and values in pairs, e.g. key at 0, value at 1, etc.
	for i := 0; i < len(mapNode.Content); i += 2 {
		keyNode := mapNode.Content[i]
		if keyNode.Kind == yaml.ScalarNode && keyNode.Value == toDelete {
			// Remove the key-value pair.
			mapNode.Content = append(mapNode.Content[:i], mapNode.Content[i+2:]...)
			return nil // Key found and deleted
		}
	}

	return nil // Key not found
}
